from IPython.display import HTML

html_breakout_game = """
<style>
  body {
    font-family: 'Arial', sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    background-color: #f0f0f0;
  }
  #game-container {
    background-color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    text-align: center;
  }
  #gameCanvas {
    background-color: #333;
    border: 2px solid #555;
    display: block; /* Remove extra space below canvas */
    margin: 0 auto;
  }
  #gameStatusMessage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2em;
    color: white;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 20px;
    border-radius: 10px;
    display: none;
    z-index: 100;
  }
  #restartButton {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    font-size: 1.2em;
    cursor: pointer;
    margin-top: 20px;
    display: none; /* Hidden by default */
    z-index: 101;
    position: absolute;
    top: 65%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
  #restartButton:hover {
    background-color: #45a049;
  }
</style>

<div id="game-container">
  <h1>Breakout Game</h1>
  <canvas id="gameCanvas" width="480" height="320"></canvas>
  <div id="gameStatusMessage"></div>
  <button id="restartButton">もう一度プレイ</button>
</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Ball properties
  const ballRadius = 10;
  let x = canvas.width / 2;
  let y = canvas.height - 30;
  let dx = 2; // Ball's X-direction speed
  let dy = -2; // Ball's Y-direction speed

  // Paddle properties
  const paddleHeight = 10;
  const paddleWidth = 75;
  let paddleX = (canvas.width - paddleWidth) / 2; // Paddle's starting X-position
  let rightPressed = false;
  let leftPressed = false;

  // Brick properties
  const brickRowCount = 3;
  const brickColumnCount = 5;
  const brickWidth = 75;
  const brickHeight = 20;
  const brickPadding = 10;
  const brickOffsetTop = 30;
  const brickOffsetLeft = 30;

  // Falling Item properties
  const itemRadius = 8; // Radius of falling items
  const itemSpeed = 1.5; // Falling speed of items
  const itemColor = '#FFD700'; // Color for falling items (e.g., gold)
  const fallingItems = []; // Array to hold falling items

  // Game State
  let score = 0;
  let bricksRemaining = brickRowCount * brickColumnCount;
  let gameRunning = true;
  const gameStatusMessageDiv = document.getElementById('gameStatusMessage');
  const restartButton = document.getElementById('restartButton');

  // Game Intervals (declared with let to allow re-assignment)
  let gameInterval;
  let itemGenerationInterval;

  // Bricks array
  const bricks = [];
  for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
      bricks[c][r] = { x: 0, y: 0, status: 1 }; // status 1 means draw the brick
    }
  }

  // Event listeners for paddle control
  document.addEventListener('keydown', keyDownHandler, false);
  document.addEventListener('keyup', keyUpHandler, false);

  function keyDownHandler(e) {
    if (e.key === 'Right' || e.key === 'ArrowRight') {
      rightPressed = true;
    } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
      leftPressed = true;
    }
  }

  function keyUpHandler(e) {
    if (e.key === 'Right' || e.key === 'ArrowRight') {
      rightPressed = false;
    } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
      leftPressed = false;
    }
  }

  function drawBall() {
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = '#0095DD';
    ctx.fill();
    ctx.closePath();
  }

  function drawPaddle() {
    ctx.beginPath();
    ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
    ctx.fillStyle = '#0095DD';
    ctx.fill();
    ctx.closePath();
  }

  function drawBricks() {
    for (let c = 0; c < brickColumnCount; c++) {
      for (let r = 0; r < brickRowCount; r++) {
        if (bricks[c][r].status === 1) {
          const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
          const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
          bricks[c][r].x = brickX;
          bricks[c][r].y = brickY;
          ctx.beginPath();
          ctx.rect(brickX, brickY, brickWidth, brickHeight);
          ctx.fillStyle = '#0095DD';
          ctx.fill();
          ctx.closePath();
        }
      }
    }
  }

  function drawScore() {
    ctx.font = '16px Arial';
    ctx.fillStyle = '#0095DD';
    ctx.fillText('Score: ' + score, 8, 20);
  }

  function generateFallingItem() {
    if (gameRunning) {
      const itemX = Math.random() * (canvas.width - 2 * itemRadius) + itemRadius;
      fallingItems.push({ x: itemX, y: 0, dy: itemSpeed });
    }
  }

  function checkItemPaddleCollision(item) {
    if (
      item.y + itemRadius > canvas.height - paddleHeight &&
      item.x + itemRadius > paddleX &&
      item.x - itemRadius < paddleX + paddleWidth
    ) {
      return true;
    }
    return false;
  }

  function drawFallingItems() {
    for (let i = 0; i < fallingItems.length; i++) {
      const item = fallingItems[i];
      ctx.beginPath();
      ctx.arc(item.x, item.y, itemRadius, 0, Math.PI * 2);
      ctx.fillStyle = itemColor;
      ctx.fill();
      ctx.closePath();

      item.y += item.dy;

      if (checkItemPaddleCollision(item)) {
        score += 10;
        fallingItems.splice(i, 1);
        i--;
      } else if (item.y - itemRadius > canvas.height) {
        // If item falls off screen
        if (gameRunning) { // Only trigger game over if game is still active
          gameRunning = false;
          gameStatusMessageDiv.textContent = 'ゲームオーバー！アイテムを取り逃しました！';
          gameStatusMessageDiv.style.display = 'block';
          restartButton.style.display = 'block';
          clearInterval(gameInterval);
          clearInterval(itemGenerationInterval);
        }
        fallingItems.splice(i, 1);
        i--;
      }
    }
  }

  function collisionDetection() {
    for (let c = 0; c < brickColumnCount; c++) {
      for (let r = 0; r < brickRowCount; r++) {
        const b = bricks[c][r];
        if (b.status === 1) {
          if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
            dy = -dy;
            b.status = 0;
            score++;
            bricksRemaining--;
            if (bricksRemaining === 0) {
              gameRunning = false;
              gameStatusMessageDiv.textContent = 'ゲームクリア！おめでとうございます！';
              gameStatusMessageDiv.style.display = 'block';
              restartButton.style.display = 'block';
              clearInterval(gameInterval);
              clearInterval(itemGenerationInterval);
            }
          }
        }
      }
    }
  }

  function initGameIntervals() {
      gameInterval = setInterval(draw, 10);
      itemGenerationInterval = setInterval(generateFallingItem, 2000);
  }

  function resetGame() {
      clearInterval(gameInterval); // Clear any existing game interval
      clearInterval(itemGenerationInterval); // Clear any existing item generation interval

      // Reset ball position and speed
      x = canvas.width / 2;
      y = canvas.height - 30;
      dx = 2;
      dy = -2;

      // Reset paddle position
      paddleX = (canvas.width - paddleWidth) / 2;

      // Reset score and brick count
      score = 0;
      bricksRemaining = brickRowCount * brickColumnCount;

      // Clear falling items
      fallingItems.length = 0; // Efficiently clear the array

      // Reset bricks status
      for (let c = 0; c < brickColumnCount; c++) {
          for (let r = 0; r < brickRowCount; r++) {
              bricks[c][r].status = 1;
          }
      }

      // Reset game state and hide messages/buttons
      gameRunning = true;
      gameStatusMessageDiv.style.display = 'none';
      gameStatusMessageDiv.textContent = '';
      restartButton.style.display = 'none'; // Hide restart button

      // Start new intervals
      initGameIntervals();
  }

  function draw() {
    if (!gameRunning) {
      return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawBall();
    drawPaddle();
    drawScore();
    drawFallingItems();
    collisionDetection();

    // Ball movement logic
    if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
      dx = -dx;
    }
    if (y + dy < ballRadius) {
      dy = -dy;
    } else if (y + dy > canvas.height - ballRadius - paddleHeight) {
      if (x > paddleX && x < paddleX + paddleWidth) {
        dy = -dy;
      } else if (y + dy > canvas.height - ballRadius) {
        gameRunning = false;
        gameStatusMessageDiv.textContent = 'ゲームオーバー！';
        gameStatusMessageDiv.style.display = 'block';
        restartButton.style.display = 'block';
        clearInterval(gameInterval);
        clearInterval(itemGenerationInterval);
      }
    }

    x += dx;
    y += dy;

    // Paddle movement logic
    if (rightPressed && paddleX < canvas.width - paddleWidth) {
      paddleX += 7;
    } else if (leftPressed && paddleX > 0) {
      paddleX -= 7;
    }
  }

  // Event listener for restart button
  restartButton.addEventListener('click', resetGame);

  // Initial game setup: Start intervals and ensure restart button is hidden
  initGameIntervals();
  restartButton.style.display = 'none';
</script>
"""

display(HTML(html_breakout_game))
